#!/bin/sh
# The next line will execute tclsh on this script: \
  exec $TCLSH "$0" "$@"

#
# First, load the cdbtcl.so file.  Note: this will fail if you have not done
#
# make cdbtcl.so
#
# in the main dcdb src directory.
#
set SLE [info sharedlibextension]
if [ catch {load ../../lib/libcdbtcl$SLE} result ] {
  puts stderr "flogadd2.tcl: could not load ../../lib/libcdbtcl$SLE: $result"
  exit 1
}

#
# Source the file that tells us how many times to iterate.
#
if [ catch { source ./flogadd2_inc.tcl } result ] {
  puts stderr "source ./flogadd2_inc.tcl: $result"
  exit 1
}
file delete -force ./flogadd2_inc.tcl

#
# Delete any tables/indexes from a previous iteration.
#
set status [ file exists flogadd2_1.db ]
if { $status } {
  file delete -force flogadd2_1.db
  file delete -force flogadd2_1.db.LCK
  file delete -force f2_1_ssnidx.inx
  file delete -force f2_1_ssnidx.idx
  file delete -force f2_1_lfmidx.inx
  file delete -force f2_1_lfmidx.idx

}

set status [ file exists flogadd2_2.db ]
if { $status } {
  file delete -force flogadd2_2.db
  file delete -force flogadd2_2.db.LCK
  file delete -force f2_2_ssnidx.inx
  file delete -force f2_2_ssnidx.idx
}

set fadd2 [ open flogadd2.df w 0644 ]
puts $fadd2 {// flogadd2.df}
puts $fadd2 {create table "flogadd2_1.db"}
puts $fadd2 {  info "Table for flogadd2.tcl"}
puts $fadd2 "{"
puts $fadd2 {  "LName" char (65);}
puts $fadd2 {  "SSNumber" char (9);}
puts $fadd2 {  "FName" char (35);}
puts $fadd2 {  "NumberLicenses" number (2:0);}
puts $fadd2 "\} indexed \{"
puts $fadd2 {  idx "f2_1_ssnidx" 256:case:unique "SSNumber";}
puts $fadd2 {  midx "f2_1_lfmidx" 512:case "LName", "FName";}
puts $fadd2 "\};"
puts $fadd2 ""
puts $fadd2 {create table "flogadd2_2.db"}
puts $fadd2 {  info "Table for flogadd2.tcl"}
puts $fadd2 "{"
puts $fadd2 {  "SSNumber" char (9);}
puts $fadd2 {  "License" char (7);}
puts $fadd2 "\} indexed \{"
puts $fadd2 {  idx "f2_2_ssnidx" 256:case:dup "SSNumber";}
puts $fadd2 "\};"
puts $fadd2 ""
close $fadd2

#
# Create the tables and indexes.
#
# BUGBUG - continue here.
if [ catch { dbcreate flogadd2.df } result ] {
  puts stderr "Creating table/indexes from flogadd2.df:"
  puts stderr "$result"
  exit 1
}

if [ catch { set table [ dbopen flogadd2_1.db ] } result ] {
  puts stderr "Opening flogadd2_1.db: $result"
  exit 1
}
if {$table == ""} {
  puts stderr "Opening flogadd2_1.db: opened by another process."
  exit 1
}
if [ catch { set tbl1 [ dbopen flogadd2_2.db ] } result ] {
  puts stderr "Opening flogadd2_2.db: $result"
  dbexit
  exit 1
}
if {$tbl1 == ""} {
  puts stderr "Opening flogadd2_2.db: opened by another process."
  exit 1
}
file delete -force flogadd2.df

#
# First, populate the table with data generated by using the dbtest* 
# commands.
#
set clock1 [ dbtime ]

set counter 0
set modulus 10
set mod_inc 1
set ssnList [ list ]
while { $counter < $numLoop } {
  incr counter
  set output [ expr $counter%1000 ]
  if { $output == 0 } {
    puts -nonewline "."
    flush stdout
  }
  if [ catch { set LName [ dbtestupperstring 0 65 ] } result ] {
    puts stderr "dbtestupperstring 0 65: $result"
    dbexit
    exit 1
  }
  if [ catch { dbsetchar $table LName $LName } result ] {
    puts "dbsetchar for LName: $result"
    dbexit
    exit 1
  }
  if [ catch { set SSNumber [ dbtestnumber 9 0 ] } result ] {
    puts stderr "dbtestnumber 9 0: $result"
    dbexit
    exit 1
  }
  if [ catch { dbsetchar $table SSNumber $SSNumber } result ] {
    puts "dbsetchar for SSNumber: $result"
    dbexit
    exit 1
  }
  if [ catch { set FName [ dbtestupperstring 0 35 ] } result ] {
    puts "dbtestupperstring 0 35: $result"
    dbexit
    exit 1
  }
  if [ catch { dbsetchar $table FName $FName } result ] {
    puts "dbsetchar for FName: $result"
    dbexit
    exit 1
  }
  set clk [ clock seconds ]
  set RAND [ expr $clk % $modulus ]
  if { $RAND == 0 } {
    set RAND 10
  }
  incr modulus $mod_inc
  if { $modulus > 40 } {
    set mod_inc -1
  }
  if { $modulus < 10 } {
    set mod_inc 1
  }
  if [ catch { dbsetnum $table NumberLicenses $RAND } result ] {
    puts "dbsetnum $table NumberLicenses $RAND: $result"
    dbexit
    exit 1
  }
  #
  # Add them
  #
  if [ catch { dbadd $table } result ] {
    if { $result == "adding record: unique index constraint violated" } {
      incr counter -1
      continue
    }
    puts "Calling dbadd: $result"
    dbexit
    exit 1
  }
  #
  # Now, add $RAND items to the secondary table.
  #
  for { set i 0 } { $i < $RAND } { incr i 1 } {
    if [ catch { dbsetchar $tbl1 SSNumber $SSNumber } result ] {
      puts "dbsetchar $tbl1 SSNumber: $result"
      dbexit
      exit 1
    }
    if [ catch { set license [ dbtestnumstring 7 0 ] } result ] {
      puts "dbtestnumstring 7 0: $result"
      dbexit
      exit 1
    }
    if [ catch { dbsetchar $tbl1 License $license } result ] {
      puts "dbsetchar $tbl1 License: $result"
      dbexit
      exit 1
    }
    if [ catch { dbadd $tbl1 } result ] {
      puts "dbadd $tbl1: $result"
      dbexit
      exit 1
    }
  }
  lappend ssnList $SSNumber
}

dbclose $table
dbclose $tbl1

if [ catch { set table [ dbopen flogadd2_1.db ] } result ] {
  puts stderr "Opening flogadd2_1.db the second time: $result"
  exit 1
}
if {$table == ""} {
  puts stderr "Opening flogadd2_1.db: opened by another process."
  exit 1
}

if [ catch { set tbl1 [ dbopen flogadd2_2.db ] } result ] {
  puts stderr "Opening flogadd2_2.db the second time: $result"
  dbexit
  exit 1
}
if {$tbl1 == ""} {
  puts stderr "Opening flogadd2_2.db: opened by another process."
  exit 1
}

set clock2 [ dbtime ]
set nowTime [ expr $clock2-$clock1 ]
set thisTime [ format "%6.4f" $nowTime ]

set num_table [ dbnumrecs $table ]
set num_tbl1 [ dbnumrecs $tbl1 ]
puts ""
puts "Finished adding..."
puts "$num_table items in $table" 
puts "$num_tbl1 items in $tbl1"
puts "Done in $thisTime seconds"


set clock1 [ dbtime ]

#
# Now, traverse through the table and make sure the data is consistent with
# what was entered.
#
set counter 0
dbcurrent $table f2_1_ssnidx
dbcurrent $tbl1 f2_2_ssnidx
set status [dbiseof $table]
if { $status == 1 } {
  puts stderr "There are no records in $table!"
  dbexit
  exit 1
}

foreach ssn $ssnList {
  incr counter

  set status [ dbsearchexact $table $ssn ]
  if { $status == 0 } {
    puts "***Warning: couldn't find $ssn in $table: entry $counter"
    continue
  }
  #
  # Found it, check the NumberLicenses field and make sure there are 
  # that many entries in the secondary.
  #
  if [ catch { dbretrieve $table } result ] {
    puts stderr "Could not retrieve from $table: $result"
    dbexit
    exit 1
  }
  if [ catch { set numLicenses [ dbshow $table NumberLicenses ] } result ] {
    puts stderr "dbshow $table NumberLicenses: $result"
    dbexit
    exit 1
  }
  set status [ dbsearchexact $tbl1 $ssn ]
  if { $status == 0 } {
    puts "***Warning: couldn't find $ssn in $tbl1"
    continue
  }
  for { set i 0 } { $i < $numLicenses } { incr i 1 } {
    if [ catch { set status [ dbretrieve $tbl1 ] } result ] {
      puts stderr "dbretrieve $tbl1: $result"
      dbexit
      exit 1
    }
    if { $status == 0 } {
      dbnextindex $tbl1
    }
    set this_ssn [ dbshow $tbl1 SSNumber ]
    if { $this_ssn != $ssn } {
      puts "***Warning: ssn from $table ($ssn) != ssn from $tbl1 ($this_ssn)"
    }
    dbnextindex $tbl1
  }
}


dbexit

set clock2 [ dbtime ]
set nowTime [ expr $clock2-$clock1 ]
set thisTime [ format "%6.4f" $nowTime ]

puts ""
puts "Verified the table data in $thisTime seconds"
exit 0

